import pandas as pd
import numpy as np
from scipy.stats import ttest_ind, mannwhitneyu
import matplotlib.pyplot as plt
import seaborn as sns

#импортируем данные с листов Excel
data = pd.read_excel('Новый диплом датасет.xlsx', sheet_name='Данные')
clients = pd.read_excel('Новый диплом датасет.xlsx', sheet_name='Clients')
regions = pd.read_excel('Новый диплом датасет.xlsx', sheet_name='Region_dict')

#чистим данные таблиц
data = data.loc[(data['id_order'].notnull()) & (data['id_client'].notnull()) & (data['amt_payment'].notnull()) & (data['dtime_pay'].notnull())]
clients = clients.loc[(clients['id_client'].notnull()) & (clients['dtime_ad'].notnull()) & (clients['nflag_test'].notnull()) & (clients['id_trading_point'].notnull())]
regions = regions.loc[(regions['id_trading_point'].notnull()) & (regions['city'].notnull())]

#распределение количества ТТ по городам
regions_gr = regions.groupby('city').agg({'id_trading_point':'count'}).reset_index()

#сумма платежей на каждого клиента
data_gr1 = data.groupby('id_client').agg({'amt_payment':'sum'})

#соединяем таблицы с данными для анализа в единую
clients_pay = pd.merge(clients, data_gr1, how = 'left', left_on = 'id_client', right_on = 'id_client')
clients_pay['amt_payment'] = clients_pay['amt_payment'].fillna(0)
clients_pay = pd.merge(clients_pay, regions, how = 'left', left_on = 'id_trading_point', right_on = 'id_trading_point')
clients_pay['nflag_pay'] = np.where(clients_pay['amt_payment'] > 0, 1, 0)

#Группируем данные для расчета средних значений платежа и конверсии в оплату
data_gr2 = clients_pay.groupby(['nflag_test', 'id_trading_point']).agg({'amt_payment': 'mean', 'nflag_pay':'sum', 'id_client':'count'}).reset_index()
data_gr2 = data_gr2.loc[data_gr2['nflag_pay'] > 0]
data_gr2['conv'] = data_gr2['nflag_pay'] / data_gr2['id_client']
# print(data_gr2.sort_values(by = 'id_trading_point'))

#Функция расчета t-критерия
def Ttest (x1, x2):
    # p_value = .05
    s, p = ttest_ind(x1, x2)
    # if p <= p_value:
    #     print('Средние значения анализируемых выборок не равны')
    #     print('s = ', s, ', p = ', p)
    # elif p > p_value:
    #     print('Средние значения анализируемых выборок равны')
    #     print('s = ', s, ', p = ', p)
    return s, p

#Функция расчета критерия Манна Уитни
def mf_func(x1, x2):
    # p_value = .05
    s, p = mannwhitneyu(x1, x2)
    # if p <= p_value:
    #     print('Средние значения анализируемых выборок не равны')
    #     print('s = ', s, ', p = ', p)
    # elif p > p_value:
    #     print('Средние значения анализируемых выборок равны')
    #     print('s = ', s, ', p = ', p)
    return s, p

# Средние значения платежей и конверсии в оплату вцелом по тестовой и контрольной группе
# t1 = Ttest(clients_pay[clients_pay['nflag_test'] == 0]['amt_payment'], clients_pay[clients_pay['nflag_test'] == 1]['amt_payment'])
# t2 = Ttest(clients_pay[clients_pay['nflag_test'] == 0]['nflag_pay'], clients_pay[clients_pay['nflag_test'] == 1]['nflag_pay'])
# mf1 = mf_func(clients_pay[clients_pay['nflag_test'] == 0]['amt_payment'], clients_pay[clients_pay['nflag_test'] == 1]['amt_payment'])
# mf2 = mf_func(clients_pay[clients_pay['nflag_test'] == 0]['nflag_pay'], clients_pay[clients_pay['nflag_test'] == 1]['nflag_pay'])

#Отбираем торговые точки с нулевой покупкой
zero_amt = []
zero_cnt=[]
for i in clients_pay['id_trading_point'].unique():
    sum0 = clients_pay[(clients_pay['id_trading_point'] == i) & (clients_pay['nflag_test'] == 0)]['amt_payment'].sum()
    sum1 = clients_pay[(clients_pay['id_trading_point'] == i) & (clients_pay['nflag_test'] == 1)]['amt_payment'].sum()
    cnt0 = clients_pay[(clients_pay['id_trading_point'] == i) & (clients_pay['nflag_test'] == 0)].count()['amt_payment']
    cnt1 = clients_pay[(clients_pay['id_trading_point'] == i) & (clients_pay['nflag_test'] == 1)].count()['amt_payment']
    if (sum0 == 0) or (sum1 == 0):
        zero_amt.append(i)
    elif (cnt0 == 0) or (cnt1 == 1):
        zero_cnt.append(i)

#очищенная таблица и гистограмма распределений средних платежей с сегментацией по группам Тест и Контроль
clients_pay2 = clients_pay[~clients_pay['id_trading_point'].isin(zero_amt)]
sns.displot(clients_pay2[clients_pay2['amt_payment'] > 0], x = 'amt_payment', hue = 'nflag_test')
plt.show()
plt.boxplot(clients_pay2['amt_payment'])
plt.show()

# сравнение средних платежей по ТТ
# for i in clients_pay2['city'].unique():
#     print('Город: ', i)
#     var = clients_pay2[clients_pay2['city'] == i]
#     for j in var['id_trading_point'].unique():
#         print('Торговая точка №', j)
#         print(Ttest(var[(var['nflag_test'] == 0) & (var['id_trading_point'] == j)]['amt_payment'], var[(var['nflag_test'] == 1) & (var['id_trading_point'] == j)]['amt_payment']))
#         print(mf_func(var[var['nflag_test'] == 0]['amt_payment'], var[var['nflag_test'] == 1]['amt_payment']))
#         print()

# сравнение средней конверсии в оплату по ТТ
# for i in clients_pay2['city'].unique():
#     print('Город: ', i)
#     var = clients_pay2[clients_pay2['city'] == i]
#     for j in var['id_trading_point'].unique():
#         print('Торговая точка №', j)
#         print(Ttest(var[(var['nflag_test'] == 0) & (var['id_trading_point'] == j)]['nflag_pay'], var[(var['nflag_test'] == 1) & (var['id_trading_point'] == j)]['nflag_pay']))
#         print(mf_func(var[var['nflag_test'] == 0]['nflag_pay'], var[var['nflag_test'] == 1]['nflag_pay']))
#         print()

# создаем и заполняем датафрейм с результатами исследования
research_result = pd.DataFrame(columns = ['city', 'id_trading_point', 'count_test', 'count_control', 'count_all', 'percent_count', 'avg_payment_test', 'avg_payment_control', 'diff', 'sigma_test', 'sigma_control', 'ttest', 'pvalue_ttest', 'outcome'])
for i in clients_pay2['city'].unique():
    cl_pay = clients_pay2[clients_pay2['city'] == i]
    # print(cl_pay)
    for j in cl_pay['id_trading_point'].unique():
        cl_pay2 = cl_pay[cl_pay['id_trading_point'] == j]
        # print(cl_pay2)
        count_test = len(cl_pay2[cl_pay2['nflag_test'] == 1])
        count_control = len(cl_pay2[cl_pay2['nflag_test'] == 0])
        count_all = count_test + count_control
        percent_count = count_all / len(clients_pay2['id_client'])
        avg_payment_test = np.mean(cl_pay2[cl_pay2['nflag_test'] == 1]['amt_payment'])
        avg_payment_control = np.mean(cl_pay2[cl_pay2['nflag_test'] == 0]['amt_payment'])
        diff = avg_payment_test - avg_payment_control
        sigma_test = cl_pay2[cl_pay2['nflag_test'] == 1]['amt_payment'].std()
        sigma_control = cl_pay2[cl_pay2['nflag_test'] == 0]['amt_payment'].std()
        s, p = Ttest(cl_pay2[cl_pay2['nflag_test'] == 0]['amt_payment'], cl_pay2[cl_pay2['nflag_test'] == 1]['amt_payment'])
        if (diff > 0) & (p < 0.05):
            outcome = 'Положительный исход'
        elif (diff < 0) & (p < 0.05):
            outcome = 'Отрицательный исход'
        else:
            outcome = 'Нейтральный исход'
        dict = {'city': [i],
                'id_trading_point': [j],
                'count_test': [count_test],
                'count_control': [count_control],
                'count_all': [count_all],
                'percent_count': [percent_count],
                'avg_payment_test': [avg_payment_test],
                'avg_payment_control': [avg_payment_control],
                'diff': [diff],
                'sigma_test': [sigma_test],
                'sigma_control': [sigma_control],
                'ttest': [s],
                'pvalue_ttest': [p],
                'outcome': [outcome]}
        df_dict = pd.DataFrame(dict)
        # print(df_dict)
        research_result = pd.concat([research_result, df_dict], ignore_index = True)
print(research_result)

# разбиваем вывод результатов на 3 датафрейма
out1 = research_result[research_result['outcome'] == 'Положительный исход']
out2 = research_result[research_result['outcome'] == 'Отрицательный исход']
out3 = research_result[research_result['outcome'] == 'Нейтральный исход']

# выгружаем результат на отдельные листы Excel
# out = pd.ExcelWriter('output.xlsx', engine = 'xlsxwriter')
# out1.to_excel (out, sheet_name = 'Положительный')
# out2.to_excel (out, sheet_name = 'Отрицательный')
# out3.to_excel (out, sheet_name = 'Нейтральный')
# out.close()
